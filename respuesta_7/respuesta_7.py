# -*- coding: utf-8 -*-
"""RESPUESTA_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17pBX9GXbglo_AW6R_rqhXTZCxvoz2onq
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pandas deap

import pandas as pd

# Cargar el dataset
file_path = '/content/drive/MyDrive/datos/diabetes_data.csv'
data = pd.read_csv(file_path)

# Mostrar las primeras filas del dataset
print(data.head())

import random
from deap import base, creator, tools

# Supongamos que tomamos la primera columna numérica como nuestros valores de x
x_values = data.iloc[:, 0].values  # Cambia el índice de columna según sea necesario

# Crear un nuevo tipo de individuo que maximiza la función objetivo
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

# Función objetivo
def eval_function(individual):
    x = individual[0]
    return x**(2*x) - 1,

# Configuración del algoritmo genético
toolbox = base.Toolbox()
toolbox.register("x", random.choice, x_values)  # Usar valores de x del dataset
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.x, n=1)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("evaluate", eval_function)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)

# Parámetros del algoritmo genético
population_size = 100
generations = 3
crossover_prob = 0.7
mutation_prob = 0.2

# Crear población inicial
population = toolbox.population(n=population_size)

# Ciclo del algoritmo genético
for gen in range(generations):
    # Evaluar la población
    fitnesses = list(map(toolbox.evaluate, population))
    for ind, fit in zip(population, fitnesses):
        ind.fitness.values = fit

    # Selección
    offspring = toolbox.select(population, len(population))
    offspring = list(map(toolbox.clone, offspring))

    # Crossover y mutación
    for child1, child2 in zip(offspring[::2], offspring[1::2]):
        if random.random() < crossover_prob:
            toolbox.mate(child1, child2)
            del child1.fitness.values
            del child2.fitness.values

    for mutant in offspring:
        if random.random() < mutation_prob:
            toolbox.mutate(mutant)
            del mutant.fitness.values

    # Reemplazo de la población
    population[:] = offspring

# Resultado final
best_individual = tools.selBest(population, 1)[0]
print(f'Best individual: {best_individual}, Fitness: {best_individual.fitness.values[0]}')

import random

# Supongamos que tomamos la primera columna numérica como nuestros valores de x
x_values = data.iloc[:, 0].values  # Cambia el índice de columna según sea necesario

# Función objetivo
def eval_function(x):
    return x**(2*x) - 1

# Inicialización de la población
def init_population(size):
    return random.choices(x_values, k=size)

# Selección de individuos
def select(population):
    return random.choices(population, k=2)

# Crossover
def crossover(parent1, parent2):
    return (parent1 + parent2) / 2  # Crossover simple

# Mutación
def mutate(individual, mutation_rate=0.1):
    if random.random() < mutation_rate:
        return individual + random.uniform(-1, 1)  # Mutación aleatoria
    return individual

# Algoritmo genético
def genetic_algorithm(generations, population_size):
    population = init_population(population_size)

    for gen in range(generations):
        # Evaluar la población
        population.sort(key=lambda x: eval_function(x), reverse=True)

        # Crear nueva población
        new_population = []

        while len(new_population) < population_size:
            parent1, parent2 = select(population)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population

    best_individual = max(population, key=lambda x: eval_function(x))
    return best_individual, eval_function(best_individual)

# Parámetros del algoritmo genético
population_size = 100
generations = 3
best_individual, best_fitness = genetic_algorithm(generations, population_size)

print(f'Best individual: {best_individual}, Fitness: {best_fitness}')